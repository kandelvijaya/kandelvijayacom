---
ID: 133
post_title: 'Mocking Vs. Stubbing: Art of Unit Testing'
author: kandelvijaya
post_date: 2015-10-26 13:33:00
post_excerpt: ""
layout: post
permalink: >
  http://kandelvijaya.com/index.php/2015/10/26/mocking-vs-stubbing-art-of-unit-testing/
published: true
---
<p>Mocking and stubbing is important when writing unit test independent of the network of some resource hogs which are inherently damn failable. It is also to test a part in isolation. But the words Stub and Mock can be intermingled without much thought. But sometimes you just want to know what are the difference despite the fact its interchanged by the Devs and some debate on it.  This article is it.</p><p><br />Regular test test for State verification. That is the typical test after going though setup, test, verify, teardown tries to pass the data and expect it to be changed or whatsoever. Its like you pass 2 numbers into a method. The way you test is assert(a+b, somethingYouKnowByHead)</p><p>Mocking is testing for Behaviour rather than the state. Now it has its advantages and disadvantages but we are looking to differentiate Mock and Stub.</p><p>When you're doing testing like this, you're focusing on one element of the software at a time -hence the common term unit testing. The problem is that to make a single unit work, you often need other units. And to make other real units is difficult, makes us think in terms of tight coupling and violates the sole principle of Unit Test. We now think in terms of how to integrate these isolated pieces in the test to just test it. In doing so undo the good practices we put in the code if all we are doing is back testing. If we are doing TDD then this might lead to a design decision of its own. Anyway, we create fakes to just pretend we had them.</p><p>Like in movies, we might be proper calling Test Doubles but thats too long for mainstream and hence we have a plethora of terminology and lets not get into the libraries.</p><p>Dummy objects are passed around but never actually used. Usually they are just used to fill parameter lists.<br />Fake objects actually have working implementations, but usually take some shortcut which makes them not suitable for production (an in memory database is a good example).<br />Stubs provide canned answers to calls made during the test, usually not responding at all to anything outside what's programmed in for the test. Stubs may also record information about calls, such as an email gateway stub that remembers the messages it 'sent', or maybe only how many messages it 'sent'.<br />Mocks are what we are talking about here: objects pre-programmed with expectations which form a specification of the calls they are expected to receive.<br />But only does Mock do behaviour verification.</p><p>**Smart way to say is: in stub you write a plain vanilla method to replace the original complicated thing and provide a fixed result. However, in Mock, take the idea further and you don't write anything but during the runtime Mocks get generated and for any method they just do nil work like in Objective-C where you would pass any method to anything at all.</p><p><br />Now the interesting thing is that mocks can be asked to respond with some method calls when they are invoked. They can be even called to return something when some method is called making them stubs. They in a sense provide the dynamic binding to take all in and to record the commands and verify if some command we are interested in happened with the given set of parameters.</p><p>Further reading and the source for this articles:<br /><a href="http://martinfowler.com/articles/mocksArentStubs.html" target="_blank" title="Martin Fowler">Martin Fowlers description on Mock vs Stubbing with Examples</a><br /><a href="http://stackoverflow.com/questions/3459287/whats-the-difference-between-a-mock-stub" target="_blank" title="Similar question on Stack Overflow questions ">Intersting question on stackoverflow about the same issue</a></p>