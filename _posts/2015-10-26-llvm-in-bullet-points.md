---
ID: 137
post_title: LLVM in bullet points
author: kandelvijaya
post_date: 2015-10-26 13:34:00
post_excerpt: ""
layout: post
permalink: >
  http://kandelvijaya.com/index.php/2015/10/26/llvm-in-bullet-points/
published: true
---
<p>##LLVM</p><p>- main feature is its internal architecture <br />-  common infrastructure to implement a broad variety of languages <br />-  best known product is the openCL GPU programming language and Runtime</p><p><br />Classical Compiler Design <br />- 3 phase static compiler design with front end, optimizer and back end <br />- Front end parses source code checking for errors and builds language specific ABSTRACT SYNTAX TREE(AST) <br />- AST is converted to new representation for optimization and then the optimization and the backend is run over it <br />- Backend, Code Generator, maps the code into the target instruction set <br />	- parts: instruction selection, register allocation and instruction scheduling</p><p><br />JVM is also a representation which uses ByteCode as interface in-between fronted AST and the Optimizer.</p><p>Some benefits:<br />- if the Optimizer can be common for many sources then we can simply plug in many language on the AST side. <br />- Back end is usually hardware oriented with the CPU and registers in mind. <br />- Portability will be easy.</p><p><br />Existing language implementations <br />- theory and practical aspect differ though doable: Java, Python, Perl Ruby share no code.<br />- There are special purpose compiler for the JIT</p><p><br />Success story <br />- Java and .Net virtual machines. They provide JIT compiler, runtime support and documentation to what the code should look like.<br />- Any language can compile to byte code <br />- But they force Garbage Collection and use of specific design choices</p><p>2nd approach: <br />Compile source to C then use C compilers. <br />- Restricts tail calls because C does not have it, bad error handling and difficult to debug a program and slows down the compilation</p><p>3rd approach:<br />- implementation of GCC.</p><p><br />All of the above approaches have a problem, we can t embed GCC into other applications. GCC is monolithic code base.</p><p>Hard to use AST without the hinderance of the optimizer and the back end to generate code documents and static analysis.</p><p>Why?<br />- rampant use of global variables <br />- weakly informed invariants <br />- poor data structures <br />- use of macros <br />- earliest design decision <br />- back end walks the front end for debugging <br />- front end makes the back end data structures to put in machine <br />- Thats why they can’t be isolated.</p><p><br />**LLVM’s code Representation: LLVM IR <br />- LLVM Intermediate Representation - a form to represent code in the compiler <br />- It is defined as a first class language with well defined semantics <br />- The llvm ir code looks like a machine independent assembly language which it is <br />- It is strongly typed <br />- LLVM IR is defined in 3 isomorphic forms: Textual format , in memory data structure and on disk byte code <br />- llvm-as takes text to byte code <br />- llvm-dis takes binary to text <br />- llvm’s optimizer is independent of the source AST and the backend meaning it can be plugged to different source with different target</p><p>- LLVM is implemented in C++ which isn’t good for pattern matching and floating point numbers</p><p>LLVM’s implementation of the 3 phase design:<br />- the front end has to generate a LLVM IR Code from the source mostly done via AST <br />- rest of the process remains the same</p><p>All it need for a new programming language to be written or the compiler is the knowledge of what LLVM IR is and how ti works . It is the only interface to the compiler and is isolated like a protocol.</p><p><br />LLVM is  a collection of Libraries ???? how?<br />- it is designed as a set of libraries rather than a monolithic code base <br />- it is a collection of useful compiler technologies that can be used in isolation if required <br />- It gives the power.</p><p>The optimizer has various passes written in C++ and they take LLVM IR and produce a faster LLVM IR to feed into backend.<br />Each pass is derived form Pass class. Passes are a case to be optimized like addition  of X + 0 is always X so replace it. Each pass is as loosely coupled as possible.</p><p><br />Library based design allows to even pick the passes and the order of execution. Moreover, the implementer can choose to implode the passes if they aren’t available.</p><p>Once the optimization is chosen the .o file is linked with the .a file only which are used on the dynamic library or the dylib</p><p>Library based design of the compiler means it is the third party responsible to use what fits rather than the system choosing.</p><p>**Design of Retargetable LLVM Code Generator <br />- Responsible to take the LLVM IR and proceed a machine dependent code <br />- This is also operate into pass of : instruction selection, register allocation, scheduling , code layout and so on <br />- No need to write everything from scratch for a little off new machine</p><p><br />- some components have dependency and it can be declared in .tb file which the tblgen will link it up</p><p><br />Other interesting features of LLVM:<br />- choose when an where each phase runs <br />- Link Time Optimization (LTO) write and do the compilation at link time <br />- Install Time Optimization  lets the app pick the best resources <br />		- for instance the code is shipped, downloaded and installed on the app and during the installation the optimization and code generation takes places <br />- Testing LLVM is easy and can be done with reason unlike on GCC where the test has to flow from the source to the end result</p><p>Further reading and the source for this article:<br /><a href="http://www.aosabook.org/en/llvm.html" target="_blank" title="LLVM explained">This awesome Explanation</a></p>